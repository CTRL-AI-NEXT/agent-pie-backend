from fastapi import APIRouter, Depends, HTTPException

# from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session

from typing import List
from agent_pie.crud import crud
from agent_pie.schemas import schemas
from agent_pie.crud import database as db
from agent_pie.agents.quiz_generator import generate_quiz_from_module
from agent_pie.agents.grader import grade_open_answer

router = APIRouter(prefix="/quizzes", tags=["quizzes"])


async def get_db():
    with db.SessionLocal() as session:
        yield session


# @router.post("/{module_id}/generate", response_model=schemas.QuizRead)
# async def generate_quiz(module_id: int, db_session: AsyncSession = Depends(get_db)):
#     quiz = await crud.create_quiz(db_session, module_id)

#     # Normally generated by agent
#     dummy_questions = [
#         schemas.QuizQuestionCreate(
#             question_text="What is the first step when preparing the recipe?",
#             question_type="mcq",
#             options=["Clean", "Serve", "Gather Ingredients"],
#             correct_answer="Gather Ingredients",
#         ),
#         schemas.QuizQuestionCreate(
#             question_text="True or False: You should cut vegetables before washing.",
#             question_type="true_false",
#             options=["True", "False"],
#             correct_answer="False",
#         ),
#     ]
#     await crud.add_quiz_questions(db_session, quiz.id, dummy_questions)
#     return await crud.get_quiz(db_session, quiz.id)


@router.post("/{module_id}/generate", response_model=schemas.QuizRead)
async def generate_quiz(module_id: int, db_session: Session = Depends(get_db)):
    quiz = crud.create_quiz(db_session, module_id)
    module = crud.get_training_module(db_session, module_id)

    module_text = " ".join([f"{s.title}: {s.description}" for s in module.steps])
    questions = generate_quiz_from_module(module_text)

    q_schema = [schemas.QuizQuestionCreate(**q) for q in questions]
    crud.add_quiz_questions(db_session, quiz.id, q_schema)

    return crud.get_quiz(db_session, quiz.id)


@router.get("/{quiz_id}", response_model=schemas.QuizRead)
async def get_quiz(quiz_id: int, db_session: Session = Depends(get_db)):
    quiz = crud.get_quiz(db_session, quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    return quiz


# @router.post("/{quiz_id}/attempt", response_model=schemas.QuizAttemptRead)
# async def attempt_quiz(
#     quiz_id: int,
#     attempt: schemas.QuizAttemptCreate,
#     db_session: AsyncSession = Depends(get_db),
# ):
#     if quiz_id != attempt.quiz_id:
#         raise HTTPException(status_code=400, detail="Quiz ID mismatch")

#     # TODO: agent should evaluate open-ended answers, for now just score dummy
#     score = 0
#     quiz = await crud.get_quiz(db_session, quiz_id)
#     for q in quiz.questions:
#         user_ans = attempt.answers.get(str(q.id))
#         if user_ans and user_ans == q.correct_answer:
#             score += 1


#     attempt.score = score
#     return await crud.create_quiz_attempt(db_session, attempt)
@router.post("/{quiz_id}/attempt", response_model=schemas.QuizAttemptRead)
async def attempt_quiz(
    quiz_id: int,
    attempt: schemas.QuizAttemptCreate,
    db_session: Session = Depends(get_db),
):
    quiz = crud.get_quiz(db_session, quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")

    score = 0
    for q in quiz.questions:
        user_ans = attempt.answers.get(str(q.id))
        if not user_ans:
            continue

        if q.question_type in ["mcq", "true_false"]:
            if user_ans == q.correct_answer:
                score += 1
        elif q.question_type == "open_ended":
            score += grade_open_answer(q.question_text, q.correct_answer, user_ans)

    attempt.score = score
    return crud.create_quiz_attempt(db_session, attempt)
